// Code generated by bpf2go; DO NOT EDIT.
//go:build mips || mips64 || ppc64 || s390x

package router

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

type RouterDatarec struct {
	Packets uint64
	Bytes   uint64
}

type RouterIfmac struct{ Mac [6]uint8 }

type RouterNeighbor struct{ Mac [6]uint8 }

type RouterNextHop struct {
	Ifindex uint32
	Gateway uint32
}

type RouterRouteKey struct {
	Prefixlen uint32
	Addr      uint32
}

// LoadRouter returns the embedded CollectionSpec for Router.
func LoadRouter() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_RouterBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load Router: %w", err)
	}

	return spec, err
}

// LoadRouterObjects loads Router and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*RouterObjects
//	*RouterPrograms
//	*RouterMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func LoadRouterObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := LoadRouter()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// RouterSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type RouterSpecs struct {
	RouterProgramSpecs
	RouterMapSpecs
	RouterVariableSpecs
}

// RouterProgramSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type RouterProgramSpecs struct {
	Router *ebpf.ProgramSpec `ebpf:"router"`
}

// RouterMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type RouterMapSpecs struct {
	Ifmap       *ebpf.MapSpec `ebpf:"ifmap"`
	NeighMap    *ebpf.MapSpec `ebpf:"neigh_map"`
	RoutesMap   *ebpf.MapSpec `ebpf:"routes_map"`
	XdpStatsMap *ebpf.MapSpec `ebpf:"xdp_stats_map"`
}

// RouterVariableSpecs contains global variables before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type RouterVariableSpecs struct {
}

// RouterObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to LoadRouterObjects or ebpf.CollectionSpec.LoadAndAssign.
type RouterObjects struct {
	RouterPrograms
	RouterMaps
	RouterVariables
}

func (o *RouterObjects) Close() error {
	return _RouterClose(
		&o.RouterPrograms,
		&o.RouterMaps,
	)
}

// RouterMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to LoadRouterObjects or ebpf.CollectionSpec.LoadAndAssign.
type RouterMaps struct {
	Ifmap       *ebpf.Map `ebpf:"ifmap"`
	NeighMap    *ebpf.Map `ebpf:"neigh_map"`
	RoutesMap   *ebpf.Map `ebpf:"routes_map"`
	XdpStatsMap *ebpf.Map `ebpf:"xdp_stats_map"`
}

func (m *RouterMaps) Close() error {
	return _RouterClose(
		m.Ifmap,
		m.NeighMap,
		m.RoutesMap,
		m.XdpStatsMap,
	)
}

// RouterVariables contains all global variables after they have been loaded into the kernel.
//
// It can be passed to LoadRouterObjects or ebpf.CollectionSpec.LoadAndAssign.
type RouterVariables struct {
}

// RouterPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to LoadRouterObjects or ebpf.CollectionSpec.LoadAndAssign.
type RouterPrograms struct {
	Router *ebpf.Program `ebpf:"router"`
}

func (p *RouterPrograms) Close() error {
	return _RouterClose(
		p.Router,
	)
}

func _RouterClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed router_bpfeb.o
var _RouterBytes []byte
